{
  "item": [
    {
      "name": "Submit Request",
      "request": {
        "name": "Submit Request",
        "description": {
          "content": "Meta API request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "submitRequest"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "\"{{value_*object}}\"",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AuthToken",
      "request": {
        "name": "AuthToken",
        "description": {
          "content": "Get authentication token",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "authToken"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null
      },
      "response": [
        {
          "name": "successful login",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"token\": \"token\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful login\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: token\n\n        pm.test(`'responseData field has token that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`token`)) {\n            const value = responseData?.token;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Deposit",
      "request": {
        "name": "Deposit",
        "description": {
          "content": "Deposit amount to customer's account",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deposit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*string}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Deposit success",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Deposit success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetAccountInfo",
      "request": {
        "name": "GetAccountInfo",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"customerId\": 9398.230174515098,\n  \"accounts\": [\n    {\n      \"customerId\": 2027.304320321579,\n      \"accountName\": \"string\",\n      \"accountNickname\": \"string\",\n      \"accountNumber\": \"string\",\n      \"accountType\": \"string\",\n      \"activatedDate\": \"string\",\n      \"availableBalance\": 2949.522350935483,\n      \"availableCash\": 1691.4449806749942,\n      \"availableCashLimit\": 6978.255574333903,\n      \"availableCredit\": 1797.9695640414418,\n      \"bankName\": \"string\",\n      \"branchName\": \"string\",\n      \"cardName\": \"string\",\n      \"cardNumber\": \"string\",\n      \"cardStatus\": \"string\",\n      \"cardType\": \"string\",\n      \"creditLimit\": 5625.401085340942,\n      \"currency\": \"string\",\n      \"currentBalance\": 9208.356749102335,\n      \"deactivatedDate\": \"string\",\n      \"dueAmount\": 6155.285629877063,\n      \"dueDate\": \"string\",\n      \"earlyWithdrawalPenalty\": 874.9441261368363,\n      \"email\": \"string\",\n      \"expDate\": \"string\",\n      \"fdType\": \"string\",\n      \"image\": \"string\",\n      \"interestRate\": 9143.511829247242,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": false,\n      \"lastDrawDate\": \"string\",\n      \"loanMaturityDate\": \"string\",\n      \"loanOriginationDate\": \"string\",\n      \"location\": \"string\",\n      \"lastUpdated\": \"string\",\n      \"maxTransactionLimit\": \"string\",\n      \"maturityDate\": \"string\",\n      \"minimumPaymentDue\": \"string\",\n      \"minimumBalance\": \"string\",\n      \"monthlyPayment\": 8511.037274249418,\n      \"openingBalance\": 724.0432374069305,\n      \"originalLoanAmount\": 8478.500450316731,\n      \"P2PLimit\": 7575.718197636652,\n      \"p2pEnabled\": 7232.420055374849,\n      \"paybillEnabled\": true,\n      \"payoffAmount\": 971.0633571069427,\n      \"personalBankerName\": \"string\",\n      \"personalBankerContact\": {\n        \"email\": \"string\",\n        \"mobileNumber\": \"string\"\n      },\n      \"phone\": 5176.41522432631,\n      \"postedBalance\": 2594.162244558673,\n      \"principalBalance\": \"string\",\n      \"productCode\": \"string\",\n      \"productName\": \"string\",\n      \"propertyAddress\": \"string\",\n      \"rewardPoints\": \"string\",\n      \"routingNumber\": \"string\",\n      \"statementDate\": \"string\",\n      \"status\": \"string\",\n      \"swiftCode\": \"string\",\n      \"totalBalance\": 9082.202442432275,\n      \"unbilledAmount\": 292.6323663978625,\n      \"valueAtMaturity\": 2257.5326654907244,\n      \"holdAmount\": 2524.0657888082983,\n      \"unclearFundsAmount\": 5964.308858629923,\n      \"averageMonthlyBalance\": 4972.556013769254,\n      \"netWithdrawableBalance\": 4435.693151644839,\n      \"totalTenure\": \"string\",\n      \"remainingTenure\": \"string\",\n      \"debitAccountNumber\": \"string\",\n      \"lateFee\": 1583.4725326766907,\n      \"bounceCharge\": 1246.0323176006516,\n      \"totalCharges\": 1726.9645368025422,\n      \"overDueAmount\": 2042.437271470885,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 1162.848662990208,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 6702.657423579681,\n          \"partialPaymentPaid\": 3998.2522846501365\n        },\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 9952.329993193965,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 6166.473545565634,\n          \"partialPaymentPaid\": 5641.992268546454\n        }\n      ],\n      \"IsCrossAccount\": false\n    },\n    {\n      \"customerId\": 7623.059626477062,\n      \"accountName\": \"string\",\n      \"accountNickname\": \"string\",\n      \"accountNumber\": \"string\",\n      \"accountType\": \"string\",\n      \"activatedDate\": \"string\",\n      \"availableBalance\": 5352.30174252121,\n      \"availableCash\": 5371.010410054988,\n      \"availableCashLimit\": 2887.623800936254,\n      \"availableCredit\": 7222.419494406878,\n      \"bankName\": \"string\",\n      \"branchName\": \"string\",\n      \"cardName\": \"string\",\n      \"cardNumber\": \"string\",\n      \"cardStatus\": \"string\",\n      \"cardType\": \"string\",\n      \"creditLimit\": 9518.378996080286,\n      \"currency\": \"string\",\n      \"currentBalance\": 5882.661311540473,\n      \"deactivatedDate\": \"string\",\n      \"dueAmount\": 9086.780358236843,\n      \"dueDate\": \"string\",\n      \"earlyWithdrawalPenalty\": 5362.075191285474,\n      \"email\": \"string\",\n      \"expDate\": \"string\",\n      \"fdType\": \"string\",\n      \"image\": \"string\",\n      \"interestRate\": 1957.6588889932277,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": true,\n      \"isAlternateMobileNumber\": true,\n      \"isStatement\": false,\n      \"lastDrawDate\": \"string\",\n      \"loanMaturityDate\": \"string\",\n      \"loanOriginationDate\": \"string\",\n      \"location\": \"string\",\n      \"lastUpdated\": \"string\",\n      \"maxTransactionLimit\": \"string\",\n      \"maturityDate\": \"string\",\n      \"minimumPaymentDue\": \"string\",\n      \"minimumBalance\": \"string\",\n      \"monthlyPayment\": 6471.274696281437,\n      \"openingBalance\": 3084.0312092110953,\n      \"originalLoanAmount\": 6610.343792389992,\n      \"P2PLimit\": 4714.749968535761,\n      \"p2pEnabled\": 2109.0104470609995,\n      \"paybillEnabled\": false,\n      \"payoffAmount\": 754.1276090660576,\n      \"personalBankerName\": \"string\",\n      \"personalBankerContact\": {\n        \"email\": \"string\",\n        \"mobileNumber\": \"string\"\n      },\n      \"phone\": 382.09650042749786,\n      \"postedBalance\": 7140.982651762453,\n      \"principalBalance\": \"string\",\n      \"productCode\": \"string\",\n      \"productName\": \"string\",\n      \"propertyAddress\": \"string\",\n      \"rewardPoints\": \"string\",\n      \"routingNumber\": \"string\",\n      \"statementDate\": \"string\",\n      \"status\": \"string\",\n      \"swiftCode\": \"string\",\n      \"totalBalance\": 8531.801597026752,\n      \"unbilledAmount\": 272.96460680112045,\n      \"valueAtMaturity\": 3217.3291139850635,\n      \"holdAmount\": 7194.884834076254,\n      \"unclearFundsAmount\": 8737.546066175992,\n      \"averageMonthlyBalance\": 8656.474250020136,\n      \"netWithdrawableBalance\": 1948.4656269671818,\n      \"totalTenure\": \"string\",\n      \"remainingTenure\": \"string\",\n      \"debitAccountNumber\": \"string\",\n      \"lateFee\": 2983.972296910824,\n      \"bounceCharge\": 6108.643965371139,\n      \"totalCharges\": 5252.349834565182,\n      \"overDueAmount\": 9479.09419066705,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 9496.217666457022,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 9662.233270691226,\n          \"partialPaymentPaid\": 6464.506979377234\n        },\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 7788.891921214411,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 3362.417921108325,\n          \"partialPaymentPaid\": 5388.4952344512785\n        }\n      ],\n      \"IsCrossAccount\": false\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'accounts' as type array'`, function() {\n          const value = responseData?.accounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.accounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`accounts`)) {\n            let accountsArray = ld.get(responseData, `accounts`, []);\n            if (Array.isArray(accountsArray)) {\n              for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                let iterator = accounts_it;\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'customerId' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNickname' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNickname;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'activatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.activatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCash' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCash;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCashLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCashLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCredit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCredit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bankName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.bankName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'branchName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.branchName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardStatus;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'creditLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.creditLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currency' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.currency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currentBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.currentBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'deactivatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.deactivatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.dueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.dueDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'earlyWithdrawalPenalty' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.earlyWithdrawalPenalty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.expDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'fdType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.fdType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'image' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.image;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'interestRate' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.interestRate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferFromEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferFromEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferToEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferToEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isPrimaryMobile' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isPrimaryMobile;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isAlternateMobileNumber' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isAlternateMobileNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isStatement' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isStatement;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastDrawDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastDrawDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanMaturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanMaturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanOriginationDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanOriginationDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastUpdated' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastUpdated;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maxTransactionLimit' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maxTransactionLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumPaymentDue' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumPaymentDue;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'monthlyPayment' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.monthlyPayment;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'openingBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.openingBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'originalLoanAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.originalLoanAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'P2PLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.P2PLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'p2pEnabled' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.p2pEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'paybillEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.paybillEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'payoffAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.payoffAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerContact' as type 'object'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerContact;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: email\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has email that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`email`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.email;\n                      console.log(`accountsArray[iterator].personalBankerContact?.email`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: mobileNumber\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has mobileNumber that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.mobileNumber;\n                      console.log(`accountsArray[iterator].personalBankerContact?.mobileNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'postedBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.postedBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'principalBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.principalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'propertyAddress' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.propertyAddress;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'rewardPoints' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.rewardPoints;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'routingNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.routingNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'statementDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.statementDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'status' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.status;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'swiftCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.swiftCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unbilledAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unbilledAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'valueAtMaturity' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.valueAtMaturity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'holdAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.holdAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unclearFundsAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unclearFundsAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'averageMonthlyBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.averageMonthlyBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'netWithdrawableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.netWithdrawableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.totalTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'remainingTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.remainingTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'debitAccountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.debitAccountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lateFee' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.lateFee;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bounceCharge' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.bounceCharge;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalCharges' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalCharges;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'overDueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.overDueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardDetails' as type array'`, function() {\n                    const value = accountsArray[iterator]?.cardDetails;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the accountsArray[${iterator}].cardDetails field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(accountsArray[iterator]).to.have.nested.property(`cardDetails`)) {\n                      let cardDetailsArray = ld.get(accountsArray[iterator], `cardDetails`, []);\n                      if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                          let iterator = cardDetails_it;\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardName;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNumber;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardImage;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardType;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.expDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.primaryCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: ATM\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: offline\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: international\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`international`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: online\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`online`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: contactless\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                                let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                                if (Array.isArray(countriesArray)) {\n                                  for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                    let iterator = countries_it;\n                                    if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                        const value = countriesArray[iterator]?.countrycode;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                                let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                                if (Array.isArray(MCCArray)) {\n                                  for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                    let iterator = MCC_it;\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.name;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.description;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.blockReason;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.autopay;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: enabled\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                                const value = cardDetailsArray[iterator].autopay?.enabled;\n                                console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: sourceAccountId\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                                const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                                console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: paymentType\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                                const value = cardDetailsArray[iterator].autopay?.paymentType;\n                                console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: onStatementDate\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                                const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                                console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: dayOfMonth\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                                const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                                console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueAmount;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'IsCrossAccount' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.IsCrossAccount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the details of the mentioned customer account",
      "request": {
        "name": "to get the details of the mentioned customer account",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountDetails"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*string}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*string}}\"\n        }\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 286.0859870028043,\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"activatedDate\": \"string\",\n    \"availableBalance\": 7446.233223303249,\n    \"availableCash\": 9837.151533134695,\n    \"availableCashLimit\": 2938.6539971319635,\n    \"availableCredit\": 2253.2957455632372,\n    \"bankName\": \"string\",\n    \"branchName\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"cardStatus\": \"string\",\n    \"cardType\": \"string\",\n    \"creditLimit\": 6401.239007401531,\n    \"currency\": \"string\",\n    \"currentBalance\": 3576.247977215823,\n    \"deactivatedDate\": \"string\",\n    \"dueAmount\": 902.5772312003344,\n    \"dueDate\": \"string\",\n    \"earlyWithdrawalPenalty\": 7260.99703416703,\n    \"email\": \"string\",\n    \"expDate\": \"string\",\n    \"fdType\": \"string\",\n    \"image\": \"string\",\n    \"interestRate\": 791.8156432124968,\n    \"internalTransferFromEnabled\": true,\n    \"internalTransferToEnabled\": true,\n    \"isPrimaryMobile\": false,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"string\",\n    \"loanMaturityDate\": \"string\",\n    \"loanOriginationDate\": \"string\",\n    \"location\": \"string\",\n    \"lastUpdated\": \"string\",\n    \"maxTransactionLimit\": \"string\",\n    \"maturityDate\": \"string\",\n    \"minimumPaymentDue\": \"string\",\n    \"minimumBalance\": \"string\",\n    \"monthlyPayment\": 5934.440552830607,\n    \"openingBalance\": 4970.12804226385,\n    \"originalLoanAmount\": 4566.299329868306,\n    \"P2PLimit\": 6864.143328857277,\n    \"p2pEnabled\": 7685.491954035275,\n    \"paybillEnabled\": true,\n    \"payoffAmount\": 6748.819630485372,\n    \"personalBankerName\": \"string\",\n    \"personalBankerContact\": {\n      \"email\": \"string\",\n      \"mobileNumber\": \"string\"\n    },\n    \"phone\": 1223.02700199846,\n    \"postedBalance\": 8239.67477217038,\n    \"principalBalance\": \"string\",\n    \"productCode\": \"string\",\n    \"productName\": \"string\",\n    \"propertyAddress\": \"string\",\n    \"rewardPoints\": \"string\",\n    \"routingNumber\": \"string\",\n    \"statementDate\": \"string\",\n    \"status\": \"string\",\n    \"swiftCode\": \"string\",\n    \"totalBalance\": 3.8801399299659423,\n    \"unbilledAmount\": 6069.6123655143965,\n    \"valueAtMaturity\": 9076.175468193516,\n    \"holdAmount\": 4535.3052860413,\n    \"unclearFundsAmount\": 5010.760531379734,\n    \"averageMonthlyBalance\": 1186.7807037149646,\n    \"netWithdrawableBalance\": 3818.9117594078502,\n    \"totalTenure\": \"string\",\n    \"remainingTenure\": \"string\",\n    \"debitAccountNumber\": \"string\",\n    \"lateFee\": 6931.16899119099,\n    \"bounceCharge\": 284.50260981459417,\n    \"totalCharges\": 5976.083433080433,\n    \"overDueAmount\": 8681.603495809963,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 8758.19591588538,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 8078.6097364412535,\n        \"partialPaymentPaid\": 5761.921187008247\n      },\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 4169.8736324006,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 4748.617000164768,\n        \"partialPaymentPaid\": 2192.5606433039025\n      }\n    ],\n    \"IsCrossAccount\": true\n  },\n  {\n    \"customerId\": 7585.8436146981885,\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"activatedDate\": \"string\",\n    \"availableBalance\": 4131.9083361810135,\n    \"availableCash\": 4565.995039377734,\n    \"availableCashLimit\": 9071.04238637232,\n    \"availableCredit\": 2259.961535992381,\n    \"bankName\": \"string\",\n    \"branchName\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"cardStatus\": \"string\",\n    \"cardType\": \"string\",\n    \"creditLimit\": 3438.7028703144874,\n    \"currency\": \"string\",\n    \"currentBalance\": 2514.153015912952,\n    \"deactivatedDate\": \"string\",\n    \"dueAmount\": 5066.33100940342,\n    \"dueDate\": \"string\",\n    \"earlyWithdrawalPenalty\": 2174.2519905731574,\n    \"email\": \"string\",\n    \"expDate\": \"string\",\n    \"fdType\": \"string\",\n    \"image\": \"string\",\n    \"interestRate\": 7956.027326384161,\n    \"internalTransferFromEnabled\": false,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": false,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"string\",\n    \"loanMaturityDate\": \"string\",\n    \"loanOriginationDate\": \"string\",\n    \"location\": \"string\",\n    \"lastUpdated\": \"string\",\n    \"maxTransactionLimit\": \"string\",\n    \"maturityDate\": \"string\",\n    \"minimumPaymentDue\": \"string\",\n    \"minimumBalance\": \"string\",\n    \"monthlyPayment\": 346.2882566369752,\n    \"openingBalance\": 5451.162336833284,\n    \"originalLoanAmount\": 2838.691310195092,\n    \"P2PLimit\": 64.58678950258978,\n    \"p2pEnabled\": 7448.275847841314,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": 9508.051049340975,\n    \"personalBankerName\": \"string\",\n    \"personalBankerContact\": {\n      \"email\": \"string\",\n      \"mobileNumber\": \"string\"\n    },\n    \"phone\": 114.51969887495306,\n    \"postedBalance\": 1215.0614722711505,\n    \"principalBalance\": \"string\",\n    \"productCode\": \"string\",\n    \"productName\": \"string\",\n    \"propertyAddress\": \"string\",\n    \"rewardPoints\": \"string\",\n    \"routingNumber\": \"string\",\n    \"statementDate\": \"string\",\n    \"status\": \"string\",\n    \"swiftCode\": \"string\",\n    \"totalBalance\": 6402.426302738983,\n    \"unbilledAmount\": 1994.177139339217,\n    \"valueAtMaturity\": 9612.971462040241,\n    \"holdAmount\": 5330.28467678162,\n    \"unclearFundsAmount\": 635.6163563450234,\n    \"averageMonthlyBalance\": 7731.884541944347,\n    \"netWithdrawableBalance\": 8910.824263103454,\n    \"totalTenure\": \"string\",\n    \"remainingTenure\": \"string\",\n    \"debitAccountNumber\": \"string\",\n    \"lateFee\": 454.36621220506845,\n    \"bounceCharge\": 7344.6302973780985,\n    \"totalCharges\": 3519.1218219049315,\n    \"overDueAmount\": 9036.379068974577,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 8881.193824014921,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 310.2307386995218,\n        \"partialPaymentPaid\": 8330.688840853869\n      },\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 5182.029278275033,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 5826.129212759905,\n        \"partialPaymentPaid\": 1885.0830033197697\n      }\n    ],\n    \"IsCrossAccount\": true\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: activatedDate\n\n              pm.test(`'item field has activatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`activatedDate`)) {\n                  const value = item?.activatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableBalance\n\n              pm.test(`'item field has availableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableBalance`)) {\n                  const value = item?.availableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCash\n\n              pm.test(`'item field has availableCash that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCash`)) {\n                  const value = item?.availableCash;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bankName\n\n              pm.test(`'item field has bankName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bankName`)) {\n                  const value = item?.bankName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: branchName\n\n              pm.test(`'item field has branchName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`branchName`)) {\n                  const value = item?.branchName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardStatus\n\n              pm.test(`'item field has cardStatus that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardStatus`)) {\n                  const value = item?.cardStatus;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardType\n\n              pm.test(`'item field has cardType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardType`)) {\n                  const value = item?.cardType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currentBalance\n\n              pm.test(`'item field has currentBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currentBalance`)) {\n                  const value = item?.currentBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: deactivatedDate\n\n              pm.test(`'item field has deactivatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`deactivatedDate`)) {\n                  const value = item?.deactivatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueAmount\n\n              pm.test(`'item field has dueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueAmount`)) {\n                  const value = item?.dueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueDate\n\n              pm.test(`'item field has dueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueDate`)) {\n                  const value = item?.dueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: earlyWithdrawalPenalty\n\n              pm.test(`'item field has earlyWithdrawalPenalty that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                  const value = item?.earlyWithdrawalPenalty;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: email\n\n              pm.test(`'item field has email that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: expDate\n\n              pm.test(`'item field has expDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`expDate`)) {\n                  const value = item?.expDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: fdType\n\n              pm.test(`'item field has fdType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`fdType`)) {\n                  const value = item?.fdType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: image\n\n              pm.test(`'item field has image that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`image`)) {\n                  const value = item?.image;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: interestRate\n\n              pm.test(`'item field has interestRate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`interestRate`)) {\n                  const value = item?.interestRate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferFromEnabled\n\n              pm.test(`'item field has internalTransferFromEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferFromEnabled`)) {\n                  const value = item?.internalTransferFromEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferToEnabled\n\n              pm.test(`'item field has internalTransferToEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferToEnabled`)) {\n                  const value = item?.internalTransferToEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isPrimaryMobile\n\n              pm.test(`'item field has isPrimaryMobile that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isPrimaryMobile`)) {\n                  const value = item?.isPrimaryMobile;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isAlternateMobileNumber\n\n              pm.test(`'item field has isAlternateMobileNumber that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n                  const value = item?.isAlternateMobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isStatement\n\n              pm.test(`'item field has isStatement that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isStatement`)) {\n                  const value = item?.isStatement;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastDrawDate\n\n              pm.test(`'item field has lastDrawDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastDrawDate`)) {\n                  const value = item?.lastDrawDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanMaturityDate\n\n              pm.test(`'item field has loanMaturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanMaturityDate`)) {\n                  const value = item?.loanMaturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanOriginationDate\n\n              pm.test(`'item field has loanOriginationDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanOriginationDate`)) {\n                  const value = item?.loanOriginationDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: location\n\n              pm.test(`'item field has location that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`location`)) {\n                  const value = item?.location;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastUpdated\n\n              pm.test(`'item field has lastUpdated that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastUpdated`)) {\n                  const value = item?.lastUpdated;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maxTransactionLimit\n\n              pm.test(`'item field has maxTransactionLimit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maxTransactionLimit`)) {\n                  const value = item?.maxTransactionLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maturityDate\n\n              pm.test(`'item field has maturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maturityDate`)) {\n                  const value = item?.maturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumPaymentDue\n\n              pm.test(`'item field has minimumPaymentDue that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumPaymentDue`)) {\n                  const value = item?.minimumPaymentDue;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumBalance\n\n              pm.test(`'item field has minimumBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumBalance`)) {\n                  const value = item?.minimumBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: monthlyPayment\n\n              pm.test(`'item field has monthlyPayment that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthlyPayment`)) {\n                  const value = item?.monthlyPayment;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: openingBalance\n\n              pm.test(`'item field has openingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`openingBalance`)) {\n                  const value = item?.openingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: originalLoanAmount\n\n              pm.test(`'item field has originalLoanAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`originalLoanAmount`)) {\n                  const value = item?.originalLoanAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: P2PLimit\n\n              pm.test(`'item field has P2PLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`P2PLimit`)) {\n                  const value = item?.P2PLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: p2pEnabled\n\n              pm.test(`'item field has p2pEnabled that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`p2pEnabled`)) {\n                  const value = item?.p2pEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paybillEnabled\n\n              pm.test(`'item field has paybillEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paybillEnabled`)) {\n                  const value = item?.paybillEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: payoffAmount\n\n              pm.test(`'item field has payoffAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`payoffAmount`)) {\n                  const value = item?.payoffAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerName\n\n              pm.test(`'item field has personalBankerName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerName`)) {\n                  const value = item?.personalBankerName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerContact\n\n              pm.test(`'item field has personalBankerContact that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerContact`)) {\n                  const value = item?.personalBankerContact;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: email\n\n              pm.test(`'item.personalBankerContact field has email that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item.personalBankerContact?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: mobileNumber\n\n              pm.test(`'item.personalBankerContact field has mobileNumber that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                  const value = item.personalBankerContact?.mobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phone\n\n              pm.test(`'item field has phone that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phone`)) {\n                  const value = item?.phone;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: postedBalance\n\n              pm.test(`'item field has postedBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`postedBalance`)) {\n                  const value = item?.postedBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: principalBalance\n\n              pm.test(`'item field has principalBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`principalBalance`)) {\n                  const value = item?.principalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productCode\n\n              pm.test(`'item field has productCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productCode`)) {\n                  const value = item?.productCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productName\n\n              pm.test(`'item field has productName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productName`)) {\n                  const value = item?.productName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: propertyAddress\n\n              pm.test(`'item field has propertyAddress that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`propertyAddress`)) {\n                  const value = item?.propertyAddress;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: rewardPoints\n\n              pm.test(`'item field has rewardPoints that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`rewardPoints`)) {\n                  const value = item?.rewardPoints;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: routingNumber\n\n              pm.test(`'item field has routingNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`routingNumber`)) {\n                  const value = item?.routingNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: statementDate\n\n              pm.test(`'item field has statementDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`statementDate`)) {\n                  const value = item?.statementDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: swiftCode\n\n              pm.test(`'item field has swiftCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`swiftCode`)) {\n                  const value = item?.swiftCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalBalance\n\n              pm.test(`'item field has totalBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalBalance`)) {\n                  const value = item?.totalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unbilledAmount\n\n              pm.test(`'item field has unbilledAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unbilledAmount`)) {\n                  const value = item?.unbilledAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: valueAtMaturity\n\n              pm.test(`'item field has valueAtMaturity that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`valueAtMaturity`)) {\n                  const value = item?.valueAtMaturity;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: holdAmount\n\n              pm.test(`'item field has holdAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`holdAmount`)) {\n                  const value = item?.holdAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unclearFundsAmount\n\n              pm.test(`'item field has unclearFundsAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unclearFundsAmount`)) {\n                  const value = item?.unclearFundsAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: averageMonthlyBalance\n\n              pm.test(`'item field has averageMonthlyBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`averageMonthlyBalance`)) {\n                  const value = item?.averageMonthlyBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: netWithdrawableBalance\n\n              pm.test(`'item field has netWithdrawableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`netWithdrawableBalance`)) {\n                  const value = item?.netWithdrawableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalTenure\n\n              pm.test(`'item field has totalTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalTenure`)) {\n                  const value = item?.totalTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: remainingTenure\n\n              pm.test(`'item field has remainingTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`remainingTenure`)) {\n                  const value = item?.remainingTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitAccountNumber\n\n              pm.test(`'item field has debitAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitAccountNumber`)) {\n                  const value = item?.debitAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lateFee\n\n              pm.test(`'item field has lateFee that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lateFee`)) {\n                  const value = item?.lateFee;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bounceCharge\n\n              pm.test(`'item field has bounceCharge that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bounceCharge`)) {\n                  const value = item?.bounceCharge;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalCharges\n\n              pm.test(`'item field has totalCharges that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalCharges`)) {\n                  const value = item?.totalCharges;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: overDueAmount\n\n              pm.test(`'item field has overDueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`overDueAmount`)) {\n                  const value = item?.overDueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'cardDetails' as type array'`, function() {\n                const value = item?.cardDetails;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.cardDetails field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`cardDetails`)) {\n                  let cardDetailsArray = ld.get(item, `cardDetails`, []);\n                  if (Array.isArray(cardDetailsArray)) {\n                    for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                      let iterator = cardDetails_it;\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardName;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNumber;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardImage;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardType;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.expDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.primaryCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: ATM\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: offline\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: international\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`international`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: online\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`online`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: contactless\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                            let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                            if (Array.isArray(countriesArray)) {\n                              for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                let iterator = countries_it;\n                                if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                    const value = countriesArray[iterator]?.countrycode;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                            let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                            if (Array.isArray(MCCArray)) {\n                              for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                let iterator = MCC_it;\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.name;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.description;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.blockReason;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.autopay;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: enabled\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                            const value = cardDetailsArray[iterator].autopay?.enabled;\n                            console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: sourceAccountId\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                            const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                            console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: paymentType\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                            const value = cardDetailsArray[iterator].autopay?.paymentType;\n                            console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: onStatementDate\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                            const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                            console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: dayOfMonth\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                            const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                            console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueAmount;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                    }\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: IsCrossAccount\n\n              pm.test(`'item field has IsCrossAccount that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`IsCrossAccount`)) {\n                  const value = item?.IsCrossAccount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountsLimit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"balance\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"currency\": \"string\",\n    \"customerId\": 3290.4640518011543,\n    \"perTxn\": 7601.752910335209,\n    \"status\": \"string\",\n    \"availableCashLimit\": 7612.360397025708,\n    \"creditLimit\": 1607.4425083401734,\n    \"availableCredit\": 5959.431439339424,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5225.397281072257,\n          \"maximum\": 3357.9631515422516,\n          \"spent\": 9918.785597835964\n        },\n        \"daily\": {\n          \"available\": 997.424509899092,\n          \"maximum\": 1955.56251639611,\n          \"spent\": 5853.702322850387\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 9378.823185377378,\n          \"maximum\": 4811.902824791423,\n          \"usedup\": 4953.910012581128\n        },\n        \"daily\": {\n          \"available\": 815.2763949066455,\n          \"maximum\": 9006.892014520688,\n          \"usedup\": 1868.0224245001998\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 7742.438842686667,\n      \"maximum\": 7220.601971180627,\n      \"usedup\": 143.9789571676786,\n      \"amountperday\": 6205.4314270061805\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 8362.25673320212,\n          \"maximum\": 8193.893939178408,\n          \"spent\": 6846.641334844705\n        },\n        \"daily\": {\n          \"available\": 9464.895634049373,\n          \"maximum\": 2943.2978924141094,\n          \"spent\": 1679.1581486806106\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 757.9559670629021,\n          \"maximum\": 8218.90828518282,\n          \"usedup\": 3300.3023030033974\n        },\n        \"daily\": {\n          \"available\": 8950.802622671454,\n          \"maximum\": 8473.258284947864,\n          \"usedup\": 4265.804550716861\n        }\n      }\n    }\n  },\n  {\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"balance\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"currency\": \"string\",\n    \"customerId\": 5192.464129393994,\n    \"perTxn\": 5908.639515200301,\n    \"status\": \"string\",\n    \"availableCashLimit\": 3064.2138679255804,\n    \"creditLimit\": 3376.7652387906264,\n    \"availableCredit\": 7868.77297921365,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 8930.352746747756,\n          \"maximum\": 4552.192072901329,\n          \"spent\": 1301.1224077519955\n        },\n        \"daily\": {\n          \"available\": 1448.883814701436,\n          \"maximum\": 5303.68364114232,\n          \"spent\": 5460.311645981584\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 582.9962840663571,\n          \"maximum\": 9930.25112230025,\n          \"usedup\": 6362.298741405135\n        },\n        \"daily\": {\n          \"available\": 8453.68982600466,\n          \"maximum\": 3488.021405213133,\n          \"usedup\": 1524.6830443326799\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 7365.459373587934,\n      \"maximum\": 368.6485774214865,\n      \"usedup\": 6465.912314816831,\n      \"amountperday\": 9325.042665268198\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 1615.0303818514833,\n          \"maximum\": 7771.475316168115,\n          \"spent\": 5576.378397877768\n        },\n        \"daily\": {\n          \"available\": 5956.973034597903,\n          \"maximum\": 8589.423383338417,\n          \"spent\": 1790.3621727802931\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 7359.826761175407,\n          \"maximum\": 5273.934659024404,\n          \"usedup\": 7588.841988287889\n        },\n        \"daily\": {\n          \"available\": 9577.51783734126,\n          \"maximum\": 3121.171345845268,\n          \"usedup\": 9034.331560915372\n        }\n      }\n    }\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: balance\n\n              pm.test(`'item field has balance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`balance`)) {\n                  const value = item?.balance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amountperday\n\n              pm.test(`'item.txnsPerDay field has amountperday that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountperday`)) {\n                  const value = item.txnsPerDay?.amountperday;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountSpecificLimitsInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 1045300,\n    \"currency\": \"USD\",\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 5,\n      \"maximum\": 8,\n      \"usedup\": 3,\n      \"amount\": 500\n    },\n    \"perTxn\": 500\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amount\n\n              pm.test(`'item.txnsPerDay field has amount that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item.txnsPerDay?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateAccountInfo",
      "request": {
        "name": "UpdateAccountInfo",
        "description": {
          "content": "Update customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCustomerInfo",
      "request": {
        "name": "GetCustomerInfo",
        "description": {
          "content": "fetch customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"alternatePhoneNumber\": 3401.1981359971433,\n  \"customerId\": \"string\",\n  \"email\": \"string\",\n  \"identificationNumber\": 7439.723471162481,\n  \"identificationType\": \"string\",\n  \"image\": \"string\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": true,\n  \"location\": \"string\",\n  \"name\": \"string\",\n  \"firstName\": \"string\",\n  \"lastName\": \"string\",\n  \"personalBanker\": {\n    \"name\": \"string\",\n    \"email\": \"string\",\n    \"mobileNumber\": \"string\"\n  },\n  \"phone\": 8768.018211914272,\n  \"securityQuestions\": [\n    \"string\",\n    \"string\"\n  ],\n  \"segmentId\": 1997.626810924451\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: firstName\n\n        pm.test(`'responseData field has firstName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`firstName`)) {\n            const value = responseData?.firstName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lastName\n\n        pm.test(`'responseData field has lastName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lastName`)) {\n            const value = responseData?.lastName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateCustomerInfo",
      "request": {
        "name": "UpdateCustomerInfo",
        "description": {
          "content": "Update customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetTransactions",
      "request": {
        "name": "GetTransactions",
        "description": {
          "content": "Fetch transactions information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetTransactions"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetTransactions"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 4777.712921858383,\n    \"transactionId\": 7990.725525198277,\n    \"accountNumber\": \"string\",\n    \"timestamp\": 6829.406100905284,\n    \"amount\": 3263.1163607477156,\n    \"currency\": \"string\",\n    \"debitOrCredit\": \"string\",\n    \"description\": \"string\",\n    \"paymentMode\": \"string\",\n    \"DBANames\": \"string\",\n    \"status\": \"string\",\n    \"closingBalance\": 5532.50148308976,\n    \"transacitonType\": \"string\",\n    \"ACHCode\": \"string\",\n    \"MCCCode\": \"string\",\n    \"SICCode\": \"string\",\n    \"name\": \"string\",\n    \"address\": \"string\",\n    \"street\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"zip\": \"string\",\n    \"country\": \"string\",\n    \"phoneNumber\": 3105.25712886055,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  },\n  {\n    \"customerId\": 4711.38288249441,\n    \"transactionId\": 4799.335487004621,\n    \"accountNumber\": \"string\",\n    \"timestamp\": 2497.5710730689093,\n    \"amount\": 181.5193333212717,\n    \"currency\": \"string\",\n    \"debitOrCredit\": \"string\",\n    \"description\": \"string\",\n    \"paymentMode\": \"string\",\n    \"DBANames\": \"string\",\n    \"status\": \"string\",\n    \"closingBalance\": 7159.809551035425,\n    \"transacitonType\": \"string\",\n    \"ACHCode\": \"string\",\n    \"MCCCode\": \"string\",\n    \"SICCode\": \"string\",\n    \"name\": \"string\",\n    \"address\": \"string\",\n    \"street\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"zip\": \"string\",\n    \"country\": \"string\",\n    \"phoneNumber\": 8331.504989213743,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transactionId\n\n              pm.test(`'item field has transactionId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactionId`)) {\n                  const value = item?.transactionId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: timestamp\n\n              pm.test(`'item field has timestamp that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`timestamp`)) {\n                  const value = item?.timestamp;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: amount\n\n              pm.test(`'item field has amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitOrCredit\n\n              pm.test(`'item field has debitOrCredit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitOrCredit`)) {\n                  const value = item?.debitOrCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: description\n\n              pm.test(`'item field has description that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`description`)) {\n                  const value = item?.description;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paymentMode\n\n              pm.test(`'item field has paymentMode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paymentMode`)) {\n                  const value = item?.paymentMode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DBANames\n\n              pm.test(`'item field has DBANames that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DBANames`)) {\n                  const value = item?.DBANames;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: closingBalance\n\n              pm.test(`'item field has closingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`closingBalance`)) {\n                  const value = item?.closingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transacitonType\n\n              pm.test(`'item field has transacitonType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transacitonType`)) {\n                  const value = item?.transacitonType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ACHCode\n\n              pm.test(`'item field has ACHCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ACHCode`)) {\n                  const value = item?.ACHCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: MCCCode\n\n              pm.test(`'item field has MCCCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`MCCCode`)) {\n                  const value = item?.MCCCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SICCode\n\n              pm.test(`'item field has SICCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SICCode`)) {\n                  const value = item?.SICCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: name\n\n              pm.test(`'item field has name that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`name`)) {\n                  const value = item?.name;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: address\n\n              pm.test(`'item field has address that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`address`)) {\n                  const value = item?.address;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: street\n\n              pm.test(`'item field has street that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`street`)) {\n                  const value = item?.street;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: city\n\n              pm.test(`'item field has city that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`city`)) {\n                  const value = item?.city;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: state\n\n              pm.test(`'item field has state that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`state`)) {\n                  const value = item?.state;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: zip\n\n              pm.test(`'item field has zip that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`zip`)) {\n                  const value = item?.zip;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: country\n\n              pm.test(`'item field has country that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`country`)) {\n                  const value = item?.country;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phoneNumber\n\n              pm.test(`'item field has phoneNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phoneNumber`)) {\n                  const value = item?.phoneNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'metaInfo' as type array'`, function() {\n                const value = item?.metaInfo;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.metaInfo field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`metaInfo`)) {\n                  let metaInfoArray = ld.get(item, `metaInfo`, []);\n                  if (Array.isArray(metaInfoArray)) {\n                    for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                      let iterator = metaInfo_it;\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'name' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.name;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'value' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.value;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                    }\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "TransferFunds",
      "request": {
        "name": "TransferFunds",
        "description": {
          "content": "Transfers funds between accounts",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "TransferFunds"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*string}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Transaction success",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Transaction success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetScheduleTransfers",
      "request": {
        "name": "GetScheduleTransfers",
        "description": {
          "content": "Fetches the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 8462.90376717089,\n    \"Amount\": 1929.3453934877425,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"InvoiceNumber\": 49.17164205876068,\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 8925.884374956679,\n    \"NextScheduleDate\": 8143.087279411674,\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 8634.33080317508,\n    \"Amount\": 3277.2316973493407,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"InvoiceNumber\": 7542.253501576348,\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 9893.28252264211,\n    \"NextScheduleDate\": 2592.1358744354216,\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: InvoiceNumber\n\n              pm.test(`'item field has InvoiceNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`InvoiceNumber`)) {\n                  const value = item?.InvoiceNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: NextScheduleDate\n\n              pm.test(`'item field has NextScheduleDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`NextScheduleDate`)) {\n                  const value = item?.NextScheduleDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateScheduleTransfers",
      "request": {
        "name": "UpdateScheduleTransfers",
        "description": {
          "content": "Update the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteScheduleTransfers",
      "request": {
        "name": "DeleteScheduleTransfers",
        "description": {
          "content": "Delete the scheduled transfer",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AddRecurringTransfers",
      "request": {
        "name": "AddRecurringTransfers",
        "description": {
          "content": "Adds the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "AddRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer added successfully",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer added successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetRecurringTransfers",
      "request": {
        "name": "GetRecurringTransfers",
        "description": {
          "content": "Fetches all the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 8267.807382720825,\n    \"Amount\": 6697.214563076152,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 6552.078114613522,\n    \"recurringOptions\": {\n      \"amountType\": \"string\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"string\",\n          \"untilDate\": \"string\",\n          \"numberOfPayments\": \"string\"\n        },\n        \"iterate\": \"string\"\n      }\n    },\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 5688.310567523776,\n    \"Amount\": 6776.214981881472,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 974.2143938687997,\n    \"recurringOptions\": {\n      \"amountType\": \"string\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"string\",\n          \"untilDate\": \"string\",\n          \"numberOfPayments\": \"string\"\n        },\n        \"iterate\": \"string\"\n      }\n    },\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: recurringOptions\n\n              pm.test(`'item field has recurringOptions that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`recurringOptions`)) {\n                  const value = item?.recurringOptions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: amountType\n\n              pm.test(`'item.recurringOptions field has amountType that is of type string'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountType`)) {\n                  const value = item.recurringOptions?.amountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: frequency\n\n              pm.test(`'item.recurringOptions field has frequency that is of type object'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`frequency`)) {\n                  const value = item.recurringOptions?.frequency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: duration\n\n              pm.test(`'item.recurringOptions.frequency field has duration that is of type object'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`duration`)) {\n                  const value = item.recurringOptions.frequency?.duration;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilStop\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilStop that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilStop`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilStop;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilDate\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilDate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilDate`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: numberOfPayments\n\n              pm.test(`'item.recurringOptions.frequency.duration field has numberOfPayments that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`numberOfPayments`)) {\n                  const value = item.recurringOptions.frequency.duration?.numberOfPayments;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: iterate\n\n              pm.test(`'item.recurringOptions.frequency field has iterate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`iterate`)) {\n                  const value = item.recurringOptions.frequency?.iterate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateRecurringTransfers",
      "request": {
        "name": "UpdateRecurringTransfers",
        "description": {
          "content": "Update the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            },\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\"\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteRecurringTransfers",
      "request": {
        "name": "DeleteRecurringTransfers",
        "description": {
          "content": "Delete the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "resetPassword",
      "request": {
        "name": "resetPassword",
        "description": {
          "content": "It allows to reset the password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "resetPassword"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"password\": \"{{password_*string}}\",\n    \"username\": \"{{username_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "password has been updated successfully.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"password has been updated successfully.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "debitcardInfoValidation",
      "request": {
        "name": "debitcardInfoValidation",
        "description": {
          "content": "for validating card info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "debitcardInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*string}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*string}}\",\n    \"expiryDate\": \"{{expiryDate_*string}}\",\n    \"pin\": \"{{pin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "personalInfoValidation",
      "request": {
        "name": "personalInfoValidation",
        "description": {
          "content": "for validating personal info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "personalInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*string}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*string}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "disputeTransaction",
      "request": {
        "name": "disputeTransaction",
        "description": {
          "content": "dispute a transaction",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "disputeTransaction"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Dispute Transactions reported successfully",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Dispute Transactions reported successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "ccPay",
      "request": {
        "name": "ccPay",
        "description": {
          "content": "to pay cc bill",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ccPay"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Credit Card payment scheduled successfully",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Credit Card payment scheduled successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCCSchedule",
      "request": {
        "name": "GetCCSchedule",
        "description": {
          "content": "Fetch cc payment list",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCCSchedule"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 6717.562230129876,\n    \"Amount\": 5191.694422761817,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 7643.349913361737,\n    \"Amount\": 6408.551300936522,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendsecuremessage",
      "request": {
        "name": "sendsecuremessage",
        "description": {
          "content": "send secure message",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendsecuremessage"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "locateProfile",
      "request": {
        "name": "locateProfile",
        "description": {
          "content": "get profile details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "locateProfile"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"accountNumber\": \"string\",\n  \"cardDetails\": {\n    \"cardNumber\": \"string\",\n    \"expiryDate\": \"string\",\n    \"cvv\": \"string\",\n    \"pin\": \"string\"\n  },\n  \"personalQuestions\": {\n    \"DOB\": \"string\",\n    \"SSN\": 7607.247302073796,\n    \"SecretPassword\": \"string\",\n    \"LDAmount\": 5083.701220377446,\n    \"AccNumber\": \"string\"\n  },\n  \"ssNumber\": 2542.4172822964942,\n  \"ssnShort\": 1921.4203720181988,\n  \"alternatePhoneNumber\": 8238.332538619536,\n  \"customerId\": \"string\",\n  \"email\": \"string\",\n  \"identificationNumber\": \"string\",\n  \"identificationType\": \"string\",\n  \"image\": \"string\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": true,\n  \"location\": \"string\",\n  \"name\": \"string\",\n  \"personalBanker\": {\n    \"name\": \"string\",\n    \"email\": \"string\",\n    \"mobileNumber\": \"string\"\n  },\n  \"phone\": 8858.459978424917,\n  \"securityQuestions\": [\n    \"string\",\n    \"string\"\n  ],\n  \"segmentId\": 2597.1337993433854,\n  \"multiAccounts\": [\n    {\n      \"accountNumber\": \"string\",\n      \"cardDetails\": {\n        \"cardNumber\": \"string\",\n        \"expiryDate\": \"string\",\n        \"cvv\": \"string\",\n        \"pin\": \"string\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"string\",\n        \"SSN\": 7498.958184686224,\n        \"SecretPassword\": \"string\",\n        \"LDAmount\": 7747.600233163101,\n        \"AccNumber\": \"string\"\n      },\n      \"ssNumber\": 7729.738647284594,\n      \"ssnShort\": 3972.6109438931157,\n      \"alternatePhoneNumber\": 4052.2293691786017,\n      \"customerId\": \"string\",\n      \"email\": \"string\",\n      \"identificationNumber\": \"string\",\n      \"identificationType\": \"string\",\n      \"location\": \"string\",\n      \"name\": \"string\",\n      \"phone\": 5589.599339770614\n    },\n    {\n      \"accountNumber\": \"string\",\n      \"cardDetails\": {\n        \"cardNumber\": \"string\",\n        \"expiryDate\": \"string\",\n        \"cvv\": \"string\",\n        \"pin\": \"string\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"string\",\n        \"SSN\": 265.2889182708473,\n        \"SecretPassword\": \"string\",\n        \"LDAmount\": 5394.889224257242,\n        \"AccNumber\": \"string\"\n      },\n      \"ssNumber\": 8865.443839920248,\n      \"ssnShort\": 5793.073261846719,\n      \"alternatePhoneNumber\": 9473.53941817092,\n      \"customerId\": \"string\",\n      \"email\": \"string\",\n      \"identificationNumber\": \"string\",\n      \"identificationType\": \"string\",\n      \"location\": \"string\",\n      \"name\": \"string\",\n      \"phone\": 9355.981954100525\n    }\n  ],\n  \"warningCodes\": [\n    {\n      \"code\": 6576.073698763427,\n      \"level\": \"string\",\n      \"description\": \"string\"\n    },\n    {\n      \"code\": 7548.189478452842,\n      \"level\": \"string\",\n      \"description\": \"string\"\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: accountNumber\n\n        pm.test(`'responseData field has accountNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n            const value = responseData?.accountNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: cardDetails\n\n        pm.test(`'responseData field has cardDetails that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardDetails`)) {\n            const value = responseData?.cardDetails;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cardNumber\n\n        pm.test(`'responseData.cardDetails field has cardNumber that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n            const value = responseData.cardDetails?.cardNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: expiryDate\n\n        pm.test(`'responseData.cardDetails field has expiryDate that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n            const value = responseData.cardDetails?.expiryDate;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cvv\n\n        pm.test(`'responseData.cardDetails field has cvv that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n            const value = responseData.cardDetails?.cvv;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: pin\n\n        pm.test(`'responseData.cardDetails field has pin that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pin`)) {\n            const value = responseData.cardDetails?.pin;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalQuestions\n\n        pm.test(`'responseData field has personalQuestions that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalQuestions`)) {\n            const value = responseData?.personalQuestions;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: DOB\n\n        pm.test(`'responseData.personalQuestions field has DOB that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n            const value = responseData.personalQuestions?.DOB;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SSN\n\n        pm.test(`'responseData.personalQuestions field has SSN that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n            const value = responseData.personalQuestions?.SSN;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SecretPassword\n\n        pm.test(`'responseData.personalQuestions field has SecretPassword that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n            const value = responseData.personalQuestions?.SecretPassword;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: LDAmount\n\n        pm.test(`'responseData.personalQuestions field has LDAmount that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n            const value = responseData.personalQuestions?.LDAmount;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: AccNumber\n\n        pm.test(`'responseData.personalQuestions field has AccNumber that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n            const value = responseData.personalQuestions?.AccNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssNumber\n\n        pm.test(`'responseData field has ssNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssNumber`)) {\n            const value = responseData?.ssNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssnShort\n\n        pm.test(`'responseData field has ssnShort that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssnShort`)) {\n            const value = responseData?.ssnShort;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'multiAccounts' as type array'`, function() {\n          const value = responseData?.multiAccounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.multiAccounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`multiAccounts`)) {\n            let multiAccountsArray = ld.get(responseData, `multiAccounts`, []);\n            if (Array.isArray(multiAccountsArray)) {\n              for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                let iterator = multiAccounts_it;\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'cardDetails' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.cardDetails;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cardNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cardNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cardNumber;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cardNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: expiryDate\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has expiryDate that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.expiryDate;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.expiryDate`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cvv\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cvv that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cvv;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cvv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: pin\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has pin that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`pin`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.pin;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.pin`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'personalQuestions' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.personalQuestions;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: DOB\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has DOB that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.DOB;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.DOB`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SSN\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SSN that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SSN;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SSN`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SecretPassword\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SecretPassword that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SecretPassword;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SecretPassword`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: LDAmount\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has LDAmount that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.LDAmount;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.LDAmount`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: AccNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has AccNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.AccNumber;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.AccNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssnShort' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssnShort;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'alternatePhoneNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.alternatePhoneNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'customerId' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationType' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'name' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.name;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'warningCodes' as type array'`, function() {\n          const value = responseData?.warningCodes;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.warningCodes field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`warningCodes`)) {\n            let warningCodesArray = ld.get(responseData, `warningCodes`, []);\n            if (Array.isArray(warningCodesArray)) {\n              for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                let iterator = warningCodes_it;\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'code' as type 'number'`, function() {\n                    const value = warningCodesArray[iterator]?.code;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'level' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.level;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'description' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.description;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the exiting user",
      "request": {
        "name": "to validate the exiting user",
        "description": {
          "content": "to validate the in of existing user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validateUser"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the pins entered by the new user",
      "request": {
        "name": "to validate the pins entered by the new user",
        "description": {
          "content": "to validate the pins entered by the new user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePIN"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate if pin entered by new user follows pin rules",
      "request": {
        "name": "to validate if pin entered by new user follows pin rules",
        "description": {
          "content": "to validate if pin entered by new user follows pin rules",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePINRules"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PIN rules satisfied",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PIN rules satisfied\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the account closure status",
      "request": {
        "name": "to fetch the account closure status",
        "description": {
          "content": "to fetch the account closure status",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "getRequestStatus"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to place the request",
      "request": {
        "name": "to place the request",
        "description": {
          "content": "to place the request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "request"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to enable or disable e or paper statements at profile level",
      "request": {
        "name": "to enable or disable e or paper statements at profile level",
        "description": {
          "content": "to enable or disable e or paper statements at profile level",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "enableEStatement"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to update the cheque book details of customer accounts",
      "request": {
        "name": "to update the cheque book details of customer accounts",
        "description": {
          "content": "Update customer cheque book details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "RequestChequeBook"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendOTP",
      "request": {
        "name": "sendOTP",
        "description": {
          "content": "sends OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "verification code has been sent to your mobile number",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"verification code has been sent to your mobile number\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "verifyOTP",
      "request": {
        "name": "verifyOTP",
        "description": {
          "content": "to verify OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "verifyOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "OTP verifid successfully",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"OTP verifid successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the deeplink",
      "request": {
        "name": "to fetch the deeplink",
        "description": {
          "content": "to fetch the deeplink",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deeplink"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "tenantId",
            "value": "{{tenantId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "environment",
            "value": "{{environment}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "channel",
            "value": "{{channel}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"usecase\": \"addbeneficiary\",\n    \"link\": \"www.google.com\",\n    \"linkType\": \"deeplink\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763544463870 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: usecase\n\n              pm.test(`'item field has usecase that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usecase`)) {\n                  const value = item?.usecase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: link\n\n              pm.test(`'item field has link that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`link`)) {\n                  const value = item?.link;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: linkType\n\n              pm.test(`'item field has linkType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`linkType`)) {\n                  const value = item?.linkType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://localhost:8080/smt",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{bearerToken}}"
      }
    ]
  },
  "info": {
    "_postman_id": "fc266322-da22-4cd9-b7dc-3c9cb88fce18",
    "name": "BankAssist SMT Core Banking API Specification",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "kore.ai banking bot apis.",
      "type": "text/plain"
    }
  }
}